<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
  <title>Angry Wolves</title>
  <style>
    :root{
      --bg:#0b0f14;
      --panel:#111823;
      --panel2:#0f1620;
      --txt:#e8eef7;
      --muted:#9bb0c9;
      --btn:#1a2636;
      --btn2:#223247;
      --accent:#ffd166;
      --ok:#7dd3fc;
    }
    html,body{
      height:100%;
      margin:0;
      background:var(--bg);
      color:var(--txt);
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, sans-serif;
      overscroll-behavior: none;
      touch-action: none;
    }
    .wrap{
      max-width: 520px;
      margin: 0 auto;
      padding: 10px 12px 18px;
    }
    header{
      display:flex;
      justify-content:space-between;
      align-items:flex-end;
      gap:12px;
      margin-bottom:10px;
    }
    .title{ line-height:1.05; }
    .title h1{
      font-size: 20px;
      margin:0;
      letter-spacing: 0.2px;
    }
    .title .sub{
      font-size: 12px;
      color:var(--muted);
      margin-top:4px;
    }
    .hud{
      text-align:right;
      font-variant-numeric: tabular-nums;
      min-width: 160px;
    }
    .hud .score{
      font-size: 18px;
      font-weight: 800;
      color: var(--accent);
    }
    .hud .meta{
      font-size: 12px;
      color: var(--muted);
      line-height: 1.3;
    }
    .hud .best{
      font-size: 12px;
      color: var(--ok);
      margin-top: 2px;
    }

    canvas{
      width: 100%;
      height: auto;
      display:block;
      background: linear-gradient(180deg, #0f1620 0%, #0b0f14 100%);
      border-radius: 14px;
      box-shadow: 0 6px 26px rgba(0,0,0,0.45);
      -webkit-tap-highlight-color: transparent;
    }

    .controls{
      margin-top:12px;
      background: var(--panel);
      border-radius: 14px;
      padding: 10px;
      display:grid;
      grid-template-columns: 1fr 1fr;
      gap: 10px;
      user-select:none;
      -webkit-user-select:none;
    }
    .cluster{
      background: var(--panel2);
      border-radius: 12px;
      padding: 10px;
      display:grid;
      grid-template-columns: 1.1fr 0.9fr 0.9fr;
      gap: 10px;
      align-items: stretch;
    }
    button{
      appearance:none;
      border: 1px solid rgba(255,255,255,0.06);
      background: var(--btn);
      color: var(--txt);
      border-radius: 12px;
      padding: 14px 12px;
      font-weight: 800;
      font-size: 14px;
      letter-spacing: 0.2px;
      box-shadow: 0 4px 10px rgba(0,0,0,0.25);
    }
    button:active{
      transform: translateY(1px);
      background: var(--btn2);
    }
    .big{ font-size: 16px; }

    .row2{
      margin-top:10px;
      display:flex;
      gap:10px;
    }
    .pill{
      flex:1;
      background: var(--panel);
      border-radius: 14px;
      padding: 10px;
      display:flex;
      justify-content:space-between;
      align-items:center;
      gap:10px;
    }
    .pill .hint{
      color: var(--muted);
      font-size: 12px;
      line-height: 1.25;
    }
    .pill .kbd{
      font-size: 12px;
      color: var(--muted);
      text-align:right;
      white-space: nowrap;
    }
    .danger{ color:#ff6b6b; font-weight:800; }

    /* Touch devices: hide desktop controls */
    .touch-only .controls,
    .touch-only .desktop-hint { display: none !important; }
  </style>
</head>
<body>
<div class="wrap" id="wrap">
  <header>
    <div class="title">
      <h1>Angry Wolves</h1>
      <div class="sub">Clear herds ‚â•10 ‚Ä¢ üêë‚Äç‚¨õ converts ‚Ä¢ üê∫ smashes</div>
    </div>
    <div class="hud">
      <div class="score"><span id="score">0</span> ü™ô</div>
      <div class="meta">Level <span id="level">1</span> ¬∑ Herds cleared <span id="clears">0</span></div>
      <div class="best" id="best">Best: ‚Äî</div>
    </div>
  </header>

  <canvas id="c"></canvas>

  <!-- Desktop-only controls -->
  <div class="controls">
    <div class="cluster">
      <button id="left" class="big">‚óÄÔ∏é</button>
      <button id="dropL">‚§ì</button>
      <button id="rotL">‚ü≤</button>
    </div>
    <div class="cluster">
      <button id="right" class="big">‚ñ∂Ô∏é</button>
      <button id="dropR">‚§ì</button>
      <button id="rotR">‚ü≥</button>
    </div>
  </div>

  <div class="row2">
    <div class="pill">
      <div class="hint">
        <span class="desktop-hint">Desktop: arrows ¬∑ Z/X rotate ¬∑ Space hard drop ¬∑ P pause</span>
        <span class="touch-hint">Touch: swipe ‚Üê/‚Üí move (hold to repeat) ¬∑ swipe ‚Üì hard drop ¬∑ tap rotate</span>
      </div>
      <div class="kbd">
        <span class="danger">üí©</span> -5 ü™ô<br/>
        ü•ö +5 ü™ô
      </div>
    </div>
  </div>
</div>

<script>
(() => {
  // ======= CONFIG =======
  const COLS = 10;
  const ROWS = 16;               // fewer rows for mobile readability (try 14‚Äì16)
  const CLEAR_THRESHOLD = 10;

  // Drop tuning
  const BASE_FALL_MS = 650;
  const MIN_FALL_MS = 120;
  const LEVEL_EVERY_LOCKS = 12;

  // Movement repeat (for swipe-hold)
  const HOLD_REPEAT_MS = 70;

  // Hard drop gesture
  const HARD_SWIPE_DY = 35;      // smaller = easier to trigger on phone
  const HARD_SWIPE_DT = 180;     // ms: must be fast

  // Spawn weights
  const WEIGHT_NORMAL = 0.88;
  const WEIGHT_BLACKSHEEP = 0.08;
  const WEIGHT_WOLVES = 0.04;

  // Powerups in normal pieces (these are ‚Äúboard tiles‚Äù that score when cleared inside herds)
  const P_EGG = 0.03;
  const P_PIE = 0.03;

  // ======= TILE CODES =======
  const TILE = {
    EMPTY: 0,
    SHEEP: 1,
    GOAT: 2,
    CHICKEN: 3,
    COW: 4,
    PIG: 5,
    PIE: 6,
    EGG: 7,
    WOLF: 8,
    BLACK_SHEEP: 9,
  };

  const ANIMALS = [TILE.SHEEP, TILE.GOAT, TILE.CHICKEN, TILE.COW, TILE.PIG];

  const TILE_LABEL = {
    [TILE.SHEEP]: "üêë",
    [TILE.GOAT]: "üêê",
    [TILE.CHICKEN]: "üêî",
    [TILE.COW]: "üêÑ",
    [TILE.PIG]: "üêñ",
    [TILE.PIE]: "üí©",
    [TILE.EGG]: "ü•ö",
    [TILE.WOLF]: "üê∫",
    [TILE.BLACK_SHEEP]: "üêë‚Äç‚¨õ",
  };

  const TILE_COLOR = {
    [TILE.SHEEP]: "#cbd5e1",
    [TILE.GOAT]: "#d4b483",
    [TILE.CHICKEN]: "#f3e8a3",
    [TILE.COW]: "#b8c0ff",
    [TILE.PIG]: "#ffb3c1",
    [TILE.PIE]: "#a07855",
    [TILE.EGG]: "#ffe08a",
    [TILE.WOLF]: "#94a3b8",
    [TILE.BLACK_SHEEP]: "#111827",
  };

  // Proper group names
  const GROUP_NAME = {
    [TILE.SHEEP]: "flock",
    [TILE.GOAT]: "herd",
    [TILE.CHICKEN]: "flock",
    [TILE.COW]: "herd",
    [TILE.PIG]: "sounder",
  };

  // ======= TETRIMINOS (standard 4x4) =======
  const SHAPES = {
    I: [
      [0,0,0,0],
      [1,1,1,1],
      [0,0,0,0],
      [0,0,0,0],
    ],
    O: [
      [0,1,1,0],
      [0,1,1,0],
      [0,0,0,0],
      [0,0,0,0],
    ],
    T: [
      [0,1,0,0],
      [1,1,1,0],
      [0,0,0,0],
      [0,0,0,0],
    ],
    S: [
      [0,1,1,0],
      [1,1,0,0],
      [0,0,0,0],
      [0,0,0,0],
    ],
    Z: [
      [1,1,0,0],
      [0,1,1,0],
      [0,0,0,0],
      [0,0,0,0],
    ],
    J: [
      [1,0,0,0],
      [1,1,1,0],
      [0,0,0,0],
      [0,0,0,0],
    ],
    L: [
      [0,0,1,0],
      [1,1,1,0],
      [0,0,0,0],
      [0,0,0,0],
    ],
  };
  const SHAPE_KEYS = Object.keys(SHAPES);

  // Specials 2x2 (no rotate)
  const SPECIAL = {
    WOLVES_2: { matrix: [[1,1],[1,1]], tile: TILE.WOLF },
    BLACKSHEEP_2: { matrix: [[1,1],[1,1]], tile: TILE.BLACK_SHEEP },
  };

  // ======= DOM =======
  const wrap = document.getElementById("wrap");
  const canvas = document.getElementById("c");
  const ctx = canvas.getContext("2d");
  const scoreEl = document.getElementById("score");
  const levelEl = document.getElementById("level");
  const clearsEl = document.getElementById("clears");
  const bestEl = document.getElementById("best");

  // Detect touch device; if touch, we run gesture-only.
  const IS_TOUCH = (("ontouchstart" in window) || (navigator.maxTouchPoints && navigator.maxTouchPoints > 0));
  if(IS_TOUCH) wrap.classList.add("touch-only");

  // ======= STATE =======
  let board = makeBoard();
  let current = null;
  let next = null;

  let score = 0;
  let level = 1;
  let locks = 0;
  let herdsCleared = 0;

  let fallTimer = 0;
  let fallInterval = BASE_FALL_MS;
  let paused = false;
  let gameOver = false;

  // Canvas sizing
  let W=0, H=0, cell=0, pad=10;

  // Audio (must start on user gesture)
  let audioCtx = null;

  // Clear feedback banner
  let banner = { text:"", t:0, ttl: 1100 }; // ms

  // ======= HELPERS =======
  function makeBoard(){
    return Array.from({length: ROWS}, () => Array(COLS).fill(TILE.EMPTY));
  }
  function cloneMatrix(m){ return m.map(r => r.slice()); }
  function randChoice(arr){ return arr[Math.floor(Math.random()*arr.length)]; }

  function rotateCW(mat){
    const n = mat.length;
    const m = mat[0].length;
    const out = Array.from({length: m}, () => Array(n).fill(0));
    for(let r=0;r<n;r++) for(let c=0;c<m;c++) out[c][n-1-r] = mat[r][c];
    return out;
  }

  function weightedSpawnKind(){
    const r = Math.random();
    if(r < WEIGHT_WOLVES) return "WOLVES";
    if(r < WEIGHT_WOLVES + WEIGHT_BLACKSHEEP) return "BLACKSHEEP";
    return "NORMAL";
  }

  function maybePowerTile(baseAnimal){
    const r = Math.random();
    if(r < P_EGG) return TILE.EGG;
    if(r < P_EGG + P_PIE) return TILE.PIE;
    return baseAnimal;
  }

  function newPiece(){
    const kind = weightedSpawnKind();
    if(kind === "WOLVES"){
      return { kind, x: Math.floor(COLS/2)-1, y: 0, matrix: cloneMatrix(SPECIAL.WOLVES_2.matrix), tile: TILE.WOLF, rotates: false };
    }
    if(kind === "BLACKSHEEP"){
      return { kind, x: Math.floor(COLS/2)-1, y: 0, matrix: cloneMatrix(SPECIAL.BLACKSHEEP_2.matrix), tile: TILE.BLACK_SHEEP, rotates: false };
    }

    const shapeKey = randChoice(SHAPE_KEYS);
    const animal = randChoice(ANIMALS);
    const base = SHAPES[shapeKey];

    const m = base.map(row => row.map(v => v ? maybePowerTile(animal) : 0));
    return { kind, shapeKey, x: Math.floor(COLS/2)-2, y: 0, matrix: m, rotates: true };
  }

  function collides(piece, dx=0, dy=0, testMatrix=null){
    const m = testMatrix ?? piece.matrix;
    for(let r=0;r<m.length;r++){
      for(let c=0;c<m[r].length;c++){
        const v = m[r][c];
        if(!v) continue;
        const x = piece.x + c + dx;
        const y = piece.y + r + dy;
        if(x < 0 || x >= COLS || y < 0 || y >= ROWS) return true;
        if(board[y][x] !== TILE.EMPTY) return true;
      }
    }
    return false;
  }

  function spawnNext(){
    current = next ?? newPiece();
    next = newPiece();
    if(collides(current,0,0)) gameOverNow();
  }

  function updateLevel(){
    level = 1 + Math.floor(locks / LEVEL_EVERY_LOCKS);
    fallInterval = Math.max(MIN_FALL_MS, Math.floor(BASE_FALL_MS * Math.pow(0.88, level-1)));
    updateHUD();
  }

  function updateHUD(){
    scoreEl.textContent = Math.max(0, score|0);
    levelEl.textContent = level;
    clearsEl.textContent = herdsCleared;

    const best = computeBestGroup();
    if(!best) bestEl.textContent = "Best: ‚Äî";
    else {
      const emoji = TILE_LABEL[best.animal] || "‚Ä¢";
      const gname = GROUP_NAME[best.animal] || "group";
      bestEl.textContent = `Best: ${best.count} ${emoji} (${gname})`;
    }
  }

  function gameOverNow(){
    gameOver = true;
    paused = true;
    draw();
    setTimeout(() => {
      alert("Game Over!\n\nTap OK to restart.");
      restart();
    }, 30);
  }

  function restart(){
    board = makeBoard();
    score = 0;
    level = 1;
    locks = 0;
    herdsCleared = 0;
    fallInterval = BASE_FALL_MS;
    paused = false;
    gameOver = false;
    current = null;
    next = null;
    banner = {text:"", t:0, ttl: 1100};
    spawnNext();
    updateHUD();
    draw();
  }

  // ======= SCORING =======
  function applyTileScoreOnClear(tile){
    if(ANIMALS.includes(tile)) score += 1;
    else if(tile === TILE.EGG) score += 5;
    else if(tile === TILE.PIE) score -= 5;
  }

  // ======= BLACK SHEEP CONVERSION =======
  function chooseConversionAnimalForBlackSheep(piece){
    const counts = new Map(ANIMALS.map(a => [a,0]));
    const footprint = [];
    for(let r=0;r<piece.matrix.length;r++){
      for(let c=0;c<piece.matrix[r].length;c++){
        if(piece.matrix[r][c]) footprint.push([piece.x + c, piece.y + r]);
      }
    }

    const dirs = [[1,0],[-1,0],[0,1],[0,-1]];
    for(const [x,y] of footprint){
      for(const [dx,dy] of dirs){
        const nx=x+dx, ny=y+dy;
        if(nx<0||nx>=COLS||ny<0||ny>=ROWS) continue;
        const t = board[ny][nx];
        if(ANIMALS.includes(t)) counts.set(t, counts.get(t)+1);
      }
    }

    let best = ANIMALS[0], bestCount = -1;
    for(const a of ANIMALS){
      const v = counts.get(a);
      if(v > bestCount){ bestCount = v; best = a; }
    }
    return (bestCount > 0) ? best : randChoice(ANIMALS);
  }

  // ======= HERD CLEARING (animals + power tiles inside the herd) =======
  // Rule: herds are for ANIMALS only, but PIE/EGG can be cleared if they are connected inside that herd.
  // PIE/EGG are treated as ‚Äúwild‚Äù tiles that can be part of the herd, but they cannot bridge between different animal types.
  function resolveBoard(){
    let anyClears = false;

    while(true){
      const clears = findAnimalHerdsToClear();
      if(clears.length === 0) break;

      anyClears = true;
      herdsCleared += clears.length;

      // Clear + score
      for(const herd of clears){
        const { animal, cells } = herd;

        // Feedback + sound once per herd
        const gname = GROUP_NAME[animal] || "group";
        const emoji = TILE_LABEL[animal] || "‚Ä¢";
        banner.text = `Cleared ${cells.length} ${emoji} (${gname})`;
        banner.t = performance.now();

        playHerdSound(animal, cells.length);

        for(const [x,y] of cells){
          applyTileScoreOnClear(board[y][x]);
          board[y][x] = TILE.EMPTY;
        }
      }

      applyGravity();
    }

    if(anyClears) updateHUD();
    else updateHUD();
  }

  function findAnimalHerdsToClear(){
    const seen = Array.from({length: ROWS}, () => Array(COLS).fill(false));
    const out = [];

    for(let y=0;y<ROWS;y++){
      for(let x=0;x<COLS;x++){
        if(seen[y][x]) continue;
        const t = board[y][x];
        if(!ANIMALS.includes(t)){
          // mark non-animal as seen (prevents pointless flood from PIE/EGG alone)
          seen[y][x] = true;
          continue;
        }

        const cells = floodAnimalWithWild(x,y,t,seen);
        if(cells.length >= CLEAR_THRESHOLD){
          out.push({ animal: t, cells });
        }
      }
    }
    return out;
  }

  function floodAnimalWithWild(sx,sy,animal,seen){
    const q = [[sx,sy]];
    const cells = [];
    seen[sy][sx] = true;

    const isWild = (t) => (t === TILE.EGG || t === TILE.PIE);

    while(q.length){
      const [x,y] = q.pop();
      cells.push([x,y]);

      const here = board[y][x];
      const dirs = [[1,0],[-1,0],[0,1],[0,-1]];

      for(const [dx,dy] of dirs){
        const nx=x+dx, ny=y+dy;
        if(nx<0||nx>=COLS||ny<0||ny>=ROWS) continue;
        if(seen[ny][nx]) continue;

        const t = board[ny][nx];

        // From an animal tile: can go to same animal OR wild
        if(ANIMALS.includes(here)){
          if(t === animal || isWild(t)){
            seen[ny][nx] = true;
            q.push([nx,ny]);
          }
        } else if(isWild(here)){
          // From a wild tile: can go to wild OR the SAME target animal only
          if(t === animal || isWild(t)){
            seen[ny][nx] = true;
            q.push([nx,ny]);
          }
        }
      }
    }

    return cells;
  }

  function applyGravity(){
    for(let x=0;x<COLS;x++){
      let write = ROWS-1;
      for(let y=ROWS-1;y>=0;y--){
        const t = board[y][x];
        if(t !== TILE.EMPTY){
          if(write !== y){
            board[write][x] = t;
            board[y][x] = TILE.EMPTY;
          }
          write--;
        }
      }
    }
  }

  function computeBestGroup(){
    // biggest ‚Äúalmost herd‚Äù currently on board (animals + wild in that herd)
    const seen = Array.from({length: ROWS}, () => Array(COLS).fill(false));
    let best = null;

    for(let y=0;y<ROWS;y++){
      for(let x=0;x<COLS;x++){
        if(seen[y][x]) continue;
        const t = board[y][x];
        if(!ANIMALS.includes(t)){
          seen[y][x] = true;
          continue;
        }
        const cells = floodAnimalWithWild(x,y,t,seen);
        if(!best || cells.length > best.count){
          best = { animal: t, count: cells.length };
        }
      }
    }
    return best;
  }

  // ======= LOCKING PIECES =======
  function lockPiece(){
    // Wolves: smash tiles directly below its 2x2 footprint, then vanish.
    if(current.kind === "WOLVES"){
      for(let r=0;r<current.matrix.length;r++){
        for(let c=0;c<current.matrix[r].length;c++){
          if(!current.matrix[r][c]) continue;
          const x = current.x + c;
          const y = current.y + r;
          const belowY = y + 1;
          if(belowY >= 0 && belowY < ROWS && x>=0 && x<COLS){
            if(board[belowY][x] !== TILE.EMPTY){
              // smashed tiles score as if cleared
              applyTileScoreOnClear(board[belowY][x]);
              board[belowY][x] = TILE.EMPTY;
            }
          }
        }
      }
      locks++;
      updateLevel();
      resolveBoard();
      spawnNext();
      return;
    }

    // Place tiles
    for(let r=0;r<current.matrix.length;r++){
      for(let c=0;c<current.matrix[r].length;c++){
        const v = current.matrix[r][c];
        if(!v) continue;
        const x = current.x + c;
        const y = current.y + r;
        if(y < 0) { gameOverNow(); return; }
        board[y][x] = v;
      }
    }

    // Black sheep: convert to best-adjacent animal on lock
    if(current.kind === "BLACKSHEEP"){
      const chosen = chooseConversionAnimalForBlackSheep(current);
      for(let r=0;r<current.matrix.length;r++){
        for(let c=0;c<current.matrix[r].length;c++){
          if(!current.matrix[r][c]) continue;
          const x = current.x + c;
          const y = current.y + r;
          board[y][x] = chosen;
        }
      }
    }

    locks++;
    updateLevel();
    resolveBoard();
    spawnNext();
  }

  // ======= INPUT / MOVEMENT =======
  function move(dx){
    if(paused) return;
    if(!collides(current, dx, 0)){
      current.x += dx;
      draw();
    }
  }

  function softDrop(){
    if(paused) return;
    if(!collides(current, 0, 1)){
      current.y += 1;
      draw();
    } else {
      lockPiece();
      draw();
    }
  }

  function hardDrop(){
    if(paused) return;
    current.y = getGhostY(current);
    lockPiece();
    draw();
  }

  function rotate(){
    if(paused) return;
    if(!current.rotates) return;
    const test = rotateCW(current.matrix);
    const kicks = [0, -1, 1, -2, 2];
    for(const k of kicks){
      if(!collides(current, k, 0, test)){
        current.matrix = test;
        current.x += k;
        draw();
        return;
      }
    }
  }

  function getGhostY(piece){
    let y = piece.y;
    while(!collides(piece, 0, (y - piece.y) + 1)) y++;
    return y;
  }

  // ======= AUDIO: simple synthesized ‚Äúanimal-ish‚Äù stingers =======
  function ensureAudio(){
    if(audioCtx) return;
    try{
      audioCtx = new (window.AudioContext || window.webkitAudioContext)();
    }catch(e){
      audioCtx = null;
    }
  }

  function playHerdSound(animal, size){
    if(!audioCtx) return;
    const t0 = audioCtx.currentTime;
    const dur = 0.14 + Math.min(0.10, size/200);

    const osc = audioCtx.createOscillator();
    const gain = audioCtx.createGain();

    // Different ‚Äúcharacter‚Äù per animal
    let type = "sine";
    let f1 = 220, f2 = 120;

    if(animal === TILE.PIG){ type="square"; f1=180; f2=90; }
    if(animal === TILE.COW){ type="sawtooth"; f1=140; f2=70; }
    if(animal === TILE.SHEEP){ type="triangle"; f1=380; f2=260; }
    if(animal === TILE.GOAT){ type="triangle"; f1=320; f2=160; }
    if(animal === TILE.CHICKEN){ type="square"; f1=520; f2=350; }

    osc.type = type;
    osc.frequency.setValueAtTime(f1, t0);
    osc.frequency.exponentialRampToValueAtTime(Math.max(40,f2), t0 + dur);

    gain.gain.setValueAtTime(0.0001, t0);
    gain.gain.exponentialRampToValueAtTime(0.18, t0 + 0.02);
    gain.gain.exponentialRampToValueAtTime(0.0001, t0 + dur);

    osc.connect(gain);
    gain.connect(audioCtx.destination);

    osc.start(t0);
    osc.stop(t0 + dur);
  }

  // ======= DRAWING =======
  function resize(){
    const rect = canvas.getBoundingClientRect();
    const dpr = Math.max(1, Math.floor(window.devicePixelRatio || 1));
    const targetW = Math.floor(rect.width * dpr);

    cell = Math.floor((targetW - pad*2*dpr) / COLS);
    W = cell * COLS + pad*2*dpr;
    H = cell * ROWS + pad*2*dpr;
    canvas.width = W;
    canvas.height = H;
    draw();
  }

  function draw(){
    ctx.clearRect(0,0,W,H);
    roundRect(ctx, 0,0,W,H, 18, true, false);

    const dpr = Math.max(1, Math.floor(window.devicePixelRatio || 1));
    const px = pad*dpr;

    // Board
    for(let y=0;y<ROWS;y++){
      for(let x=0;x<COLS;x++){
        drawCell(x,y, board[y][x], px);
      }
    }

    // Ghost
    if(current && !paused){
      const ghostY = getGhostY(current);
      drawPiece(current, 0, ghostY - current.y, px, true);
    }

    // Current
    if(current) drawPiece(current, 0, 0, px, false);

    // Grid overlay
    ctx.globalAlpha = 0.10;
    ctx.strokeStyle = "#ffffff";
    ctx.lineWidth = 1;
    for(let x=0;x<=COLS;x++){
      ctx.beginPath();
      ctx.moveTo(px + x*cell, px);
      ctx.lineTo(px + x*cell, px + ROWS*cell);
      ctx.stroke();
    }
    for(let y=0;y<=ROWS;y++){
      ctx.beginPath();
      ctx.moveTo(px, px + y*cell);
      ctx.lineTo(px + COLS*cell, px + y*cell);
      ctx.stroke();
    }
    ctx.globalAlpha = 1;

    // Banner
    if(banner.text){
      const now = performance.now();
      const age = now - banner.t;
      if(age < banner.ttl){
        const a = Math.max(0, 1 - age / banner.ttl);
        ctx.save();
        ctx.globalAlpha = 0.75 * a;
        ctx.fillStyle = "#000";
        ctx.fillRect(0,0,W, Math.floor(cell*1.2));
        ctx.globalAlpha = 1 * a;
        ctx.fillStyle = "#fff";
        ctx.font = `${Math.floor(cell*0.55)}px system-ui`;
        ctx.textAlign = "center";
        ctx.textBaseline = "middle";
        ctx.fillText(banner.text, W/2, Math.floor(cell*0.6));
        ctx.restore();
      } else {
        banner.text = "";
      }
    }

    // Pause overlay
    if(paused && !gameOver){
      ctx.save();
      ctx.globalAlpha = 0.6;
      ctx.fillStyle = "#000";
      ctx.fillRect(0,0,W,H);
      ctx.globalAlpha = 1;
      ctx.fillStyle = "#fff";
      ctx.font = `${Math.floor(cell*0.9)}px system-ui`;
      ctx.textAlign = "center";
      ctx.fillText("Paused", W/2, H/2);
      ctx.restore();
    }
  }

  function drawCell(x,y,tile, px){
    const gx = px + x*cell;
    const gy = px + y*cell;

    if(tile === TILE.EMPTY){
      ctx.globalAlpha = 0.08;
      ctx.fillStyle = "#ffffff";
      ctx.fillRect(gx+2, gy+2, cell-4, cell-4);
      ctx.globalAlpha = 1;
      return;
    }

    ctx.fillStyle = TILE_COLOR[tile] || "#ddd";
    ctx.globalAlpha = 0.95;
    roundRect(ctx, gx+1, gy+1, cell-2, cell-2, 10, true, false);
    ctx.globalAlpha = 1;

    ctx.font = `${Math.floor(cell*0.7)}px system-ui, "Apple Color Emoji", "Segoe UI Emoji"`;
    ctx.textAlign = "center";
    ctx.textBaseline = "middle";
    ctx.fillText(TILE_LABEL[tile] || "?", gx + cell/2, gy + cell/2 + 1);
  }

  function drawPiece(piece, dx, dy, px, ghost){
    const m = piece.matrix;
    ctx.save();
    if(ghost) ctx.globalAlpha = 0.22;
    for(let r=0;r<m.length;r++){
      for(let c=0;c<m[r].length;c++){
        const v = m[r][c];
        if(!v) continue;
        const x = piece.x + c + dx;
        const y = piece.y + r + dy;
        if(y < 0) continue;
        drawCell(x,y,v,px);
      }
    }
    ctx.restore();
  }

  function roundRect(ctx, x, y, w, h, r, fill, stroke){
    const rr = Math.min(r, w/2, h/2);
    ctx.beginPath();
    ctx.moveTo(x+rr, y);
    ctx.arcTo(x+w, y, x+w, y+h, rr);
    ctx.arcTo(x+w, y+h, x, y+h, rr);
    ctx.arcTo(x, y+h, x, y, rr);
    ctx.arcTo(x, y, x+w, y, rr);
    ctx.closePath();
    if(fill){
      ctx.fillStyle = "#0d141e";
      ctx.fill();
    }
    if(stroke) ctx.stroke();
  }

  // ======= TOUCH GESTURES (gesture-only on touch devices) =======
  let touchStart = null;
  let holdTimer = null;
  let holdDir = 0;

  function clearHold(){
    if(holdTimer){
      clearInterval(holdTimer);
      holdTimer = null;
    }
    holdDir = 0;
  }

  function startHold(dir){
    clearHold();
    holdDir = dir;
    move(dir);
    holdTimer = setInterval(() => move(dir), HOLD_REPEAT_MS);
  }

  canvas.addEventListener("pointerdown", (e) => {
    e.preventDefault();
    ensureAudio();
    if(audioCtx && audioCtx.state === "suspended") audioCtx.resume();

    touchStart = {x: e.clientX, y: e.clientY, t: performance.now()};
  });

  canvas.addEventListener("pointermove", (e) => {
    if(!IS_TOUCH) return;
    if(!touchStart) return;
    const dx = e.clientX - touchStart.x;
    const dy = e.clientY - touchStart.y;
    const absX = Math.abs(dx);
    const absY = Math.abs(dy);

    // If user drags horizontally enough, begin repeating movement while held.
    if(absX > 22 && absX > absY){
      startHold(dx < 0 ? -1 : 1);
      // reset start point so movement feels continuous
      touchStart.x = e.clientX;
      touchStart.y = e.clientY;
      touchStart.t = performance.now();
    }
  });

  canvas.addEventListener("pointerup", (e) => {
    e.preventDefault();
    clearHold();
    if(!touchStart) return;

    const dx = e.clientX - touchStart.x;
    const dy = e.clientY - touchStart.y;
    const dt = performance.now() - touchStart.t;

    const absX = Math.abs(dx);
    const absY = Math.abs(dy);

    // Tap = rotate
    if(absX < 12 && absY < 12 && dt < 260){
      rotate();
      touchStart = null;
      return;
    }

    // Swipe down: hard drop if fast and big enough
    if(absY > absX && dy > 0){
      if(absY >= HARD_SWIPE_DY && dt <= HARD_SWIPE_DT) hardDrop();
      else softDrop();
      touchStart = null;
      return;
    }

    // Non-hold horizontal swipe = single nudge
    if(absX > absY){
      move(dx < 0 ? -1 : 1);
    }

    touchStart = null;
  });

  canvas.addEventListener("pointercancel", () => { clearHold(); touchStart = null; });

  // ======= DESKTOP CONTROLS (only if NOT touch) =======
  function bindHold(btn, onTick, ms=60){
    let timer = null;
    const start = (e) => {
      e.preventDefault();
      onTick();
      timer = setInterval(onTick, ms);
    };
    const stop = (e) => {
      e.preventDefault();
      if(timer){ clearInterval(timer); timer = null; }
    };
    btn.addEventListener("pointerdown", start);
    btn.addEventListener("pointerup", stop);
    btn.addEventListener("pointercancel", stop);
    btn.addEventListener("pointerleave", stop);
  }

  if(!IS_TOUCH){
    const leftBtn = document.getElementById("left");
    const rightBtn = document.getElementById("right");
    const dropLBtn = document.getElementById("dropL");
    const dropRBtn = document.getElementById("dropR");
    const rotLBtn = document.getElementById("rotL");
    const rotRBtn = document.getElementById("rotR");

    bindHold(leftBtn, () => move(-1), 70);
    bindHold(rightBtn, () => move(1), 70);
    bindHold(dropLBtn, () => softDrop(), 40);
    bindHold(dropRBtn, () => softDrop(), 40);
    rotLBtn.addEventListener("pointerdown", (e) => { e.preventDefault(); rotate(); });
    rotRBtn.addEventListener("pointerdown", (e) => { e.preventDefault(); rotate(); });

    window.addEventListener("keydown", (e) => {
      const k = e.key.toLowerCase();
      if(k === "p"){ paused = !paused; draw(); return; }
      if(paused) return;

      if(e.key === "ArrowLeft") move(-1);
      else if(e.key === "ArrowRight") move(1);
      else if(e.key === "ArrowDown") softDrop();
      else if(e.key === " "){ e.preventDefault(); hardDrop(); }
      else if(k === "z" || e.key === "ArrowUp") rotate();
      else if(k === "x") rotate();
      else if(k === "r") restart();
    });
  }

  // ======= GAME LOOP =======
  function tick(){
    requestAnimationFrame(tick);
    if(paused || gameOver) return;

    if(!current){
      spawnNext();
      updateHUD();
      draw();
      return;
    }

    fallTimer += 16;
    if(fallTimer >= fallInterval){
      fallTimer = 0;
      if(!collides(current, 0, 1)){
        current.y += 1;
      } else {
        lockPiece();
      }
      draw();
    }
  }

  // ======= INIT =======
  function init(){
    window.addEventListener("resize", resize, {passive:true});
    const ro = new ResizeObserver(() => resize());
    ro.observe(canvas);

    next = newPiece();
    spawnNext();
    updateHUD();
    resize();
    requestAnimationFrame(tick);
  }

  init();
})();
</script>
</body>
</html>
