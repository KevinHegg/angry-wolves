<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
  <title>Angry Wolves</title>
  <style>
    :root{
      --bg:#060608;
      --txt:#e8e3d8;
      --muted:#a39a8b;
      --accent:#ffd166;
      --ok:#7dd3fc;
      --panel:#0b0b10cc;
      --panel2:#0e0e14;
      --btn:#151523;
      --btn2:#1e1e31;
      --danger:#ff6b6b;
    }
    html,body{
      height:100%;
      margin:0;
      background: radial-gradient(1200px 800px at 50% 0%, #0b0b10 0%, #050506 60%, #030304 100%);
      color:var(--txt);
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, sans-serif;
      overscroll-behavior: none;
      touch-action: none;
    }
    .wrap{
      max-width: 520px;
      margin: 0 auto;
      padding: 10px 12px 18px;
      position: relative;
    }
    header{
      display:flex;
      justify-content:space-between;
      align-items:flex-end;
      gap:10px;
      margin-bottom:10px;
    }
    .title{
      line-height:1.05;
      display:flex;
      align-items:flex-end;
      gap:10px;
    }
    .title h1{
      font-size: 20px;
      margin:0;
      letter-spacing: 0.3px;
    }
    .title .sub{
      font-size: 12px;
      color:var(--muted);
      margin-top:4px;
    }
    .hud{
      text-align:right;
      font-variant-numeric: tabular-nums;
      min-width: 160px;
    }
    .hud .score{
      font-size: 18px;
      font-weight: 900;
      color: var(--accent);
    }
    .hud .meta{
      font-size: 12px;
      color:var(--muted);
      line-height:1.25;
    }
    .hud .best{
      font-size: 12px;
      color: var(--ok);
      margin-top: 2px;
    }

    /* Gear button */
    .gear{
      position:absolute;
      top: 10px;
      left: 12px;
      width: 38px;
      height: 38px;
      border-radius: 12px;
      border: 1px solid rgba(255,255,255,0.08);
      background: rgba(10,10,16,0.65);
      color: var(--txt);
      display:flex;
      align-items:center;
      justify-content:center;
      font-size: 18px;
      user-select:none;
      -webkit-user-select:none;
      -webkit-tap-highlight-color: transparent;
      box-shadow: 0 8px 20px rgba(0,0,0,0.45);
    }
    .gear:active{ transform: translateY(1px); }

    canvas{
      width: 100%;
      height: auto;
      display:block;
      border-radius: 14px;
      box-shadow: 0 12px 34px rgba(0,0,0,0.60);
      -webkit-tap-highlight-color: transparent;
      background:
        /* ‚Äúbarn wood‚Äù planks */
        linear-gradient(180deg, rgba(0,0,0,0.35), rgba(0,0,0,0.65)),
        repeating-linear-gradient(
          90deg,
          rgba(90,60,35,0.16) 0px,
          rgba(90,60,35,0.16) 14px,
          rgba(60,40,22,0.12) 14px,
          rgba(60,40,22,0.12) 26px
        );
      border: 1px solid rgba(255,255,255,0.06);
    }

    .pill{
      margin-top:10px;
      background: rgba(10,10,16,0.65);
      border-radius: 14px;
      padding: 10px;
      border: 1px solid rgba(255,255,255,0.06);
      box-shadow: 0 8px 24px rgba(0,0,0,0.45);
      display:flex;
      justify-content:space-between;
      align-items:flex-start;
      gap:10px;
      color: var(--muted);
      font-size: 12px;
      line-height: 1.25;
    }
    .pill b{ color: var(--txt); }
    .pill .right{
      text-align:right;
      white-space: nowrap;
    }
    .danger{ color: var(--danger); font-weight: 900; }

    /* Settings modal */
    .modalBackdrop{
      position: fixed;
      inset: 0;
      background: rgba(0,0,0,0.55);
      display:none;
      align-items:center;
      justify-content:center;
      z-index: 10;
      padding: 16px;
    }
    .modal{
      width: min(520px, 100%);
      background: rgba(10,10,16,0.92);
      border: 1px solid rgba(255,255,255,0.10);
      border-radius: 16px;
      padding: 14px;
      box-shadow: 0 18px 60px rgba(0,0,0,0.75);
      color: var(--txt);
    }
    .modal h2{
      margin: 0 0 10px 0;
      font-size: 16px;
      letter-spacing: 0.2px;
    }
    .row{
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap: 10px;
      padding: 10px 8px;
      background: rgba(255,255,255,0.04);
      border-radius: 12px;
      border: 1px solid rgba(255,255,255,0.06);
    }
    .toggle{
      display:flex;
      align-items:center;
      gap:10px;
      user-select:none;
      -webkit-user-select:none;
    }
    .switch{
      width: 52px;
      height: 30px;
      border-radius: 999px;
      background: rgba(255,255,255,0.14);
      border: 1px solid rgba(255,255,255,0.12);
      position: relative;
    }
    .knob{
      width: 24px;
      height: 24px;
      border-radius: 50%;
      position:absolute;
      top: 2px;
      left: 2px;
      background: rgba(255,255,255,0.82);
      box-shadow: 0 6px 16px rgba(0,0,0,0.45);
      transition: transform 120ms ease;
    }
    .switch.on{
      background: rgba(255,209,102,0.28);
      border-color: rgba(255,209,102,0.22);
    }
    .switch.on .knob{ transform: translateX(22px); }

    .closeBtn{
      margin-top: 12px;
      width: 100%;
      padding: 12px;
      border-radius: 12px;
      border: 1px solid rgba(255,255,255,0.08);
      background: rgba(255,255,255,0.06);
      color: var(--txt);
      font-weight: 900;
      letter-spacing: 0.2px;
    }
    .closeBtn:active{ transform: translateY(1px); }
  </style>
</head>
<body>
<div class="wrap" id="wrap">
  <div class="gear" id="gear" title="Settings">‚öôÔ∏è</div>

  <header>
    <div>
      <div class="title">
        <h1>Angry Wolves</h1>
      </div>
      <div class="sub" style="font-size:12px;color:var(--muted);margin-top:4px;">
        Clear 10+ contiguous same animals ‚Ä¢ üêë‚Äç‚¨õ adapts ‚Ä¢ üê∫ explodes
      </div>
    </div>
    <div class="hud">
      <div class="score"><span id="score">0</span> ü™ô</div>
      <div class="meta">Level <span id="level">1</span> ¬∑ Herds <span id="clears">0</span></div>
      <div class="best" id="best">Best: ‚Äî</div>
    </div>
  </header>

  <canvas id="c"></canvas>

  <div class="pill">
    <div>
      <b>Touch:</b> swipe ‚Üê/‚Üí to move ¬∑ swipe ‚Üì to drop ¬∑ swipe ‚Üë to rotate<br/>
      (Up-left = CCW, Up-right/straight = CW). Tap = CW rotate.
    </div>
    <div class="right">
      ü•ö doubles score<br/>
      <span class="danger">üí©</span> halves score
    </div>
  </div>
</div>

<!-- Settings modal -->
<div class="modalBackdrop" id="modalBackdrop">
  <div class="modal">
    <h2>Settings</h2>
    <div class="row">
      <div class="toggle">
        <div style="font-size:18px;">üîä</div>
        <div>
          <div style="font-weight:900;">Sound</div>
          <div style="font-size:12px;color:var(--muted);margin-top:2px;">Barnyard sounds + ambience</div>
        </div>
      </div>
      <div class="switch on" id="soundSwitch" role="switch" aria-checked="true">
        <div class="knob"></div>
      </div>
    </div>
    <button class="closeBtn" id="closeModal">Done</button>
  </div>
</div>

<script>
(() => {
  // ======= CONFIG =======
  const COLS = 10;
  const ROWS = 16;
  const CLEAR_THRESHOLD = 10;

  const BASE_FALL_MS = 650;
  const MIN_FALL_MS = 120;
  const LEVEL_EVERY_LOCKS = 12;

  // gesture thresholds
  const SWIPE_STEP_X = 22;   // move one column per step of finger travel
  const SWIPE_STEP_Y = 22;   // drop one row per step of finger travel
  const SWIPE_UP_MIN  = 26;  // must be this far up to be a rotate swipe

  // Spawn weights for specials
  const WEIGHT_NORMAL = 0.88;
  const WEIGHT_BLACKSHEEP = 0.08;
  const WEIGHT_WOLVES = 0.04;

  // Background power tiles (overlays, not blocking)
  const INITIAL_EGGS = 10;
  const INITIAL_TURDS = 10;

  // Explosion radius for wolves: footprint + all adjacent (8-neighborhood) around each footprint cell
  const WOLF_BLAST = true;

  // ======= TILE CODES =======
  const TILE = {
    EMPTY: 0,
    SHEEP: 1,
    GOAT: 2,
    CHICKEN: 3,
    COW: 4,
    PIG: 5,
    WOLF: 6,
    BLACK_SHEEP: 7,
  };

  const POWER = {
    NONE: 0,
    EGG: 1,
    TURD: 2,
  };

  const ANIMALS = [TILE.SHEEP, TILE.GOAT, TILE.CHICKEN, TILE.COW, TILE.PIG];

  const TILE_LABEL = {
    [TILE.SHEEP]: "üêë",
    [TILE.GOAT]: "üêê",
    [TILE.CHICKEN]: "üêî",
    [TILE.COW]: "üêÑ",
    [TILE.PIG]: "üêñ",
    [TILE.WOLF]: "üê∫",
    [TILE.BLACK_SHEEP]: "üêë‚Äç‚¨õ",
  };

  // ‚Äúmedieval-ish‚Äù muted palette (board stays dark; tiles get the color)
  const TILE_COLOR = {
    [TILE.SHEEP]: "#cbd5e1",
    [TILE.GOAT]: "#d7b68c",
    [TILE.CHICKEN]: "#f3e6a4",
    [TILE.COW]: "#b9c7ff",
    [TILE.PIG]: "#ffc0cb",
    [TILE.WOLF]: "#7b8799",
    [TILE.BLACK_SHEEP]: "#12121a",
  };

  // Proper group names
  const GROUP_NAME = {
    [TILE.SHEEP]: "flock",
    [TILE.GOAT]: "herd",
    [TILE.CHICKEN]: "flock",
    [TILE.COW]: "herd",
    [TILE.PIG]: "sounder",
  };

  // ======= SHAPES =======
  const SHAPES = {
    I: [
      [0,0,0,0],
      [1,1,1,1],
      [0,0,0,0],
      [0,0,0,0],
    ],
    O: [
      [0,1,1,0],
      [0,1,1,0],
      [0,0,0,0],
      [0,0,0,0],
    ],
    T: [
      [0,1,0,0],
      [1,1,1,0],
      [0,0,0,0],
      [0,0,0,0],
    ],
    S: [
      [0,1,1,0],
      [1,1,0,0],
      [0,0,0,0],
      [0,0,0,0],
    ],
    Z: [
      [1,1,0,0],
      [0,1,1,0],
      [0,0,0,0],
      [0,0,0,0],
    ],
    J: [
      [1,0,0,0],
      [1,1,1,0],
      [0,0,0,0],
      [0,0,0,0],
    ],
    L: [
      [0,0,1,0],
      [1,1,1,0],
      [0,0,0,0],
      [0,0,0,0],
    ],
  };
  const SHAPE_KEYS = Object.keys(SHAPES);

  const SPECIAL = {
    WOLVES_2: { matrix: [[1,1],[1,1]], tile: TILE.WOLF, rotates:false },
    BLACKSHEEP_2: { matrix: [[1,1],[1,1]], tile: TILE.BLACK_SHEEP, rotates:false },
  };

  // ======= DOM =======
  const canvas = document.getElementById("c");
  const ctx = canvas.getContext("2d");
  const scoreEl = document.getElementById("score");
  const levelEl = document.getElementById("level");
  const clearsEl = document.getElementById("clears");
  const bestEl = document.getElementById("best");

  const gear = document.getElementById("gear");
  const modalBackdrop = document.getElementById("modalBackdrop");
  const soundSwitch = document.getElementById("soundSwitch");
  const closeModal = document.getElementById("closeModal");

  const IS_TOUCH = (("ontouchstart" in window) || (navigator.maxTouchPoints && navigator.maxTouchPoints > 0));

  // ======= STATE =======
  let board = makeBoard();
  // powerOverlay[y][x] = POWER.EGG/TURD/NONE (does not block tiles)
  let powerOverlay = makeOverlay();

  let current = null;
  let next = null;

  let score = 0;
  let level = 1;
  let locks = 0;
  let herdsCleared = 0;

  let fallTimer = 0;
  let fallInterval = BASE_FALL_MS;
  let paused = false;
  let gameOver = false;

  // Canvas sizing
  let W=0, H=0, cell=0, pad=10;

  // Audio
  let audioCtx = null;
  let soundOn = true;
  let ambienceTimer = 0;

  // Feedback banner
  let banner = { text:"", t:0, ttl: 900 };

  // Particles
  let particles = [];

  // ======= HELPERS =======
  function makeBoard(){
    return Array.from({length: ROWS}, () => Array(COLS).fill(TILE.EMPTY));
  }
  function makeOverlay(){
    return Array.from({length: ROWS}, () => Array(COLS).fill(POWER.NONE));
  }
  function randChoice(arr){ return arr[Math.floor(Math.random()*arr.length)]; }
  function clamp(v,a,b){ return Math.max(a, Math.min(b, v)); }

  function rotateCW(mat){
    const n = mat.length, m = mat[0].length;
    const out = Array.from({length: m}, () => Array(n).fill(0));
    for(let r=0;r<n;r++) for(let c=0;c<m;c++) out[c][n-1-r] = mat[r][c];
    return out;
  }
  function rotateCCW(mat){
    const n = mat.length, m = mat[0].length;
    const out = Array.from({length: m}, () => Array(n).fill(0));
    for(let r=0;r<n;r++) for(let c=0;c<m;c++) out[m-1-c][r] = mat[r][c];
    return out;
  }

  function weightedSpawnKind(){
    const r = Math.random();
    if(r < WEIGHT_WOLVES) return "WOLVES";
    if(r < WEIGHT_WOLVES + WEIGHT_BLACKSHEEP) return "BLACKSHEEP";
    return "NORMAL";
  }

  function newPiece(){
    const kind = weightedSpawnKind();
    if(kind === "WOLVES"){
      return { kind, x: Math.floor(COLS/2)-1, y: 0, matrix: clone2(SPECIAL.WOLVES_2.matrix), tile: TILE.WOLF, rotates:false };
    }
    if(kind === "BLACKSHEEP"){
      return { kind, x: Math.floor(COLS/2)-1, y: 0, matrix: clone2(SPECIAL.BLACKSHEEP_2.matrix), tile: TILE.BLACK_SHEEP, rotates:false };
    }

    const shapeKey = randChoice(SHAPE_KEYS);
    const animal = randChoice(ANIMALS);
    const base = SHAPES[shapeKey];
    const m = base.map(row => row.map(v => v ? animal : 0));
    return { kind, shapeKey, x: Math.floor(COLS/2)-2, y: 0, matrix: m, rotates:true };
  }
  function clone2(m){ return m.map(r => r.slice()); }

  function collides(piece, dx=0, dy=0, testMatrix=null){
    const m = testMatrix ?? piece.matrix;
    for(let r=0;r<m.length;r++){
      for(let c=0;c<m[r].length;c++){
        const v = m[r][c];
        if(!v) continue;
        const x = piece.x + c + dx;
        const y = piece.y + r + dy;
        if(x < 0 || x >= COLS || y < 0 || y >= ROWS) return true;
        if(board[y][x] !== TILE.EMPTY) return true;
      }
    }
    return false;
  }

  function spawnNext(){
    current = next ?? newPiece();
    next = newPiece();
    if(collides(current,0,0)) gameOverNow();
  }

  function updateLevel(){
    level = 1 + Math.floor(locks / LEVEL_EVERY_LOCKS);
    fallInterval = Math.max(MIN_FALL_MS, Math.floor(BASE_FALL_MS * Math.pow(0.88, level-1)));
    updateHUD();
  }

  function updateHUD(){
    scoreEl.textContent = Math.max(0, score|0);
    levelEl.textContent = level;
    clearsEl.textContent = herdsCleared;

    const best = computeBestGroup();
    if(!best) bestEl.textContent = "Best: ‚Äî";
    else {
      const emoji = TILE_LABEL[best.animal] || "‚Ä¢";
      const gname = GROUP_NAME[best.animal] || "group";
      bestEl.textContent = `Best: ${best.count} ${emoji} (${gname})`;
    }
  }

  function gameOverNow(){
    gameOver = true;
    paused = true;
    draw();
    setTimeout(() => {
      alert("Game Over!\n\nTap OK to restart.");
      restart();
    }, 30);
  }

  // Background power tiles: don‚Äôt block; they‚Äôre ‚Äúin the mud underfoot‚Äù
  function sprinklePowerOverlay(){
    powerOverlay = makeOverlay();
    const startRow = Math.max(ROWS-7, 0);
    placeOverlay(POWER.EGG, INITIAL_EGGS, startRow);
    placeOverlay(POWER.TURD, INITIAL_TURDS, startRow);
  }
  function placeOverlay(type, n, startRow){
    let tries = 0;
    while(n > 0 && tries < 6000){
      tries++;
      const x = Math.floor(Math.random()*COLS);
      const y = startRow + Math.floor(Math.random()*(ROWS-startRow));
      if(powerOverlay[y][x] === POWER.NONE){
        powerOverlay[y][x] = type;
        n--;
      }
    }
  }

  function restart(){
    board = makeBoard();
    sprinklePowerOverlay();
    score = 0;
    level = 1;
    locks = 0;
    herdsCleared = 0;
    fallInterval = BASE_FALL_MS;
    paused = false;
    gameOver = false;
    current = null;
    next = null;
    banner = {text:"", t:0, ttl: 900};
    particles = [];
    spawnNext();
    updateHUD();
    draw();
  }

  // ======= HAPTICS (best-effort) =======
  function haptic(ms=10){
    try{
      if("vibrate" in navigator) navigator.vibrate(ms);
    }catch{}
  }

  // ======= AUDIO =======
  function ensureAudio(){
    if(audioCtx) return;
    try{ audioCtx = new (window.AudioContext || window.webkitAudioContext)(); }
    catch{ audioCtx = null; }
  }
  function playTone({type="sine", f1=220, f2=110, dur=0.12, gain=0.12, noise=false}){
    if(!audioCtx || !soundOn) return;
    const t0 = audioCtx.currentTime;

    const g = audioCtx.createGain();
    g.gain.setValueAtTime(0.0001, t0);
    g.gain.exponentialRampToValueAtTime(gain, t0 + 0.015);
    g.gain.exponentialRampToValueAtTime(0.0001, t0 + dur);

    if(noise){
      // tiny burst of noise for ‚Äúpeck/cluck‚Äù
      const bufferSize = Math.floor(audioCtx.sampleRate * dur);
      const buffer = audioCtx.createBuffer(1, bufferSize, audioCtx.sampleRate);
      const data = buffer.getChannelData(0);
      for(let i=0;i<bufferSize;i++){
        data[i] = (Math.random()*2-1) * Math.pow(1 - i/bufferSize, 2);
      }
      const src = audioCtx.createBufferSource();
      src.buffer = buffer;
      src.connect(g);
      g.connect(audioCtx.destination);
      src.start(t0);
      src.stop(t0 + dur);
      return;
    }

    const osc = audioCtx.createOscillator();
    osc.type = type;
    osc.frequency.setValueAtTime(f1, t0);
    osc.frequency.exponentialRampToValueAtTime(Math.max(40,f2), t0 + dur);

    osc.connect(g);
    g.connect(audioCtx.destination);
    osc.start(t0);
    osc.stop(t0 + dur);
  }

  function playBarnyard(animal, size){
    // Simple ‚Äúcartoon barnyard‚Äù synth motifs
    const big = Math.min(0.18, 0.10 + size/200);
    if(animal === TILE.COW){
      playTone({type:"sawtooth", f1:150, f2:70, dur:0.16+big, gain:0.14});
      playTone({type:"sine", f1:95, f2:55, dur:0.18+big, gain:0.10});
    } else if(animal === TILE.PIG){
      playTone({type:"square", f1:190, f2:90, dur:0.12+big, gain:0.13});
      playTone({type:"square", f1:160, f2:80, dur:0.10+big, gain:0.10});
    } else if(animal === TILE.SHEEP){
      playTone({type:"triangle", f1:430, f2:280, dur:0.11+big, gain:0.12});
    } else if(animal === TILE.GOAT){
      playTone({type:"triangle", f1:320, f2:160, dur:0.14+big, gain:0.12});
      playTone({type:"sine", f1:260, f2:140, dur:0.10+big, gain:0.09});
    } else if(animal === TILE.CHICKEN){
      playTone({noise:true, dur:0.06+big, gain:0.10});
      playTone({type:"square", f1:700, f2:420, dur:0.07+big, gain:0.09});
    } else {
      playTone({type:"sine", f1:240, f2:120, dur:0.10+big, gain:0.10});
    }
  }

  function playTick(){
    // tiny ambience: faint ‚Äúwood creak‚Äù ticks
    if(!audioCtx || !soundOn) return;
    if(Math.random() < 0.03){
      playTone({type:"sine", f1:110 + Math.random()*30, f2:80, dur:0.06, gain:0.035});
    }
  }

  // ======= SCORING =======
  // Clear ONLY same-animal contiguous groups >= 10.
  // Egg/Turd are overlays: collected if a cleared herd covers them:
  //   eggs: double score per egg; turds: halve score per turd (both after base + bonus).
  function fib(n){
    // fib(1)=1, fib(2)=1, fib(3)=2 ...
    if(n <= 0) return 0;
    if(n === 1 || n === 2) return 1;
    let a=1,b=1;
    for(let i=3;i<=n;i++){ const c=a+b; a=b; b=c; }
    return b;
  }

  // ======= BLACK SHEEP CONVERSION =======
  function chooseConversionAnimalForBlackSheep(piece){
    // Look at adjacency around the 2x2 footprint; pick the most frequent animal touched.
    const counts = new Map(ANIMALS.map(a => [a,0]));
    const cells = footprintCells(piece);

    const dirs = [[1,0],[-1,0],[0,1],[0,-1]];
    for(const [x,y] of cells){
      for(const [dx,dy] of dirs){
        const nx=x+dx, ny=y+dy;
        if(nx<0||nx>=COLS||ny<0||ny>=ROWS) continue;
        const t = board[ny][nx];
        if(ANIMALS.includes(t)) counts.set(t, counts.get(t)+1);
      }
    }

    let best = null, bestCount = -1;
    for(const a of ANIMALS){
      const v = counts.get(a);
      if(v > bestCount){ bestCount = v; best = a; }
    }
    if(bestCount <= 0) return randChoice(ANIMALS);
    // If tie, randomly among tied
    const tied = ANIMALS.filter(a => counts.get(a) === bestCount);
    return tied.length ? randChoice(tied) : best;
  }

  // ======= WOLVES EXPLOSION =======
  function footprintCells(piece){
    const cells = [];
    const m = piece.matrix;
    for(let r=0;r<m.length;r++){
      for(let c=0;c<m[r].length;c++){
        if(!m[r][c]) continue;
        const x = piece.x + c;
        const y = piece.y + r;
        if(x>=0 && x<COLS && y>=0 && y<ROWS) cells.push([x,y]);
      }
    }
    return cells;
  }

  function wolvesExplode(piece){
    // explode footprint + adjacent (8-neighborhood) around each footprint cell
    const blast = new Set();
    const cells = footprintCells(piece);

    const around = [
      [0,0],[1,0],[-1,0],[0,1],[0,-1],
      [1,1],[1,-1],[-1,1],[-1,-1]
    ];

    for(const [x,y] of cells){
      for(const [dx,dy] of around){
        const nx=x+dx, ny=y+dy;
        if(nx<0||nx>=COLS||ny<0||ny>=ROWS) continue;
        blast.add(ny*COLS + nx);
      }
    }

    // Remove tiles, spawn particles. Overlays are also cleared in blast area.
    const popped = [];
    for(const key of blast){
      const x = key % COLS;
      const y = Math.floor(key / COLS);
      if(board[y][x] !== TILE.EMPTY){
        popped.push([x,y, board[y][x]]);
        board[y][x] = TILE.EMPTY;
      }
      powerOverlay[y][x] = POWER.NONE;
    }

    if(popped.length){
      spawnPopParticles(popped);
      banner.text = `üê∫ BOOM (${popped.length} tiles)`;
      banner.t = performance.now();
      if(soundOn){
        playTone({type:"sawtooth", f1:120, f2:45, dur:0.20, gain:0.18});
        playTone({type:"square", f1:80, f2:40, dur:0.16, gain:0.12});
      }
      haptic(18);
    }
  }

  // ======= CLEARING / GRAVITY =======
  function resolveBoard(){
    while(true){
      const clears = findAnimalGroupsToClear();
      if(clears.length === 0) break;

      for(const group of clears){
        const { animal, cells } = group;

        // base: +1 per tile cleared
        score += cells.length;

        // Fibonacci bonus for >10
        if(cells.length >= 11){
          const bonusIndex = cells.length - 8; // 11->3 => +2, 12->4 => +3, 13->5 => +5 ...
          score += fib(bonusIndex);
        }

        // overlay multipliers
        let eggs = 0, turds = 0;
        for(const [x,y] of cells){
          if(powerOverlay[y][x] === POWER.EGG) eggs++;
          if(powerOverlay[y][x] === POWER.TURD) turds++;
        }

        if(eggs > 0) score = Math.floor(score * Math.pow(2, eggs));
        if(turds > 0) score = Math.floor(score / Math.pow(2, turds));

        // clear tiles + clear overlays within those cells
        for(const [x,y] of cells){
          board[y][x] = TILE.EMPTY;
          powerOverlay[y][x] = POWER.NONE;
        }

        herdsCleared++;

        // feedback
        const gname = GROUP_NAME[animal] || "group";
        const emoji = TILE_LABEL[animal] || "‚Ä¢";
        const multTxt = `${eggs?(` ü•öx${eggs}`):""}${turds?(` üí©x${turds}`):""}`;
        banner.text = `Cleared ${cells.length} ${emoji} (${gname})${multTxt}`;
        banner.t = performance.now();

        playBarnyard(animal, cells.length);
        haptic(12);

        spawnPopParticles(cells.map(([x,y]) => [x,y,animal]));
      }

      applyGravity();
    }

    updateHUD();
  }

  function findAnimalGroupsToClear(){
    const seen = Array.from({length: ROWS}, () => Array(COLS).fill(false));
    const out = [];

    for(let y=0;y<ROWS;y++){
      for(let x=0;x<COLS;x++){
        if(seen[y][x]) continue;
        const t = board[y][x];
        if(!ANIMALS.includes(t)){
          seen[y][x] = true;
          continue;
        }
        const cells = floodSameAnimal(x,y,t,seen);
        if(cells.length >= CLEAR_THRESHOLD){
          out.push({ animal: t, cells });
        }
      }
    }
    return out;
  }

  function floodSameAnimal(sx,sy,animal,seen){
    const q = [[sx,sy]];
    const cells = [];
    seen[sy][sx] = true;

    while(q.length){
      const [x,y] = q.pop();
      cells.push([x,y]);

      const dirs = [[1,0],[-1,0],[0,1],[0,-1]];
      for(const [dx,dy] of dirs){
        const nx=x+dx, ny=y+dy;
        if(nx<0||nx>=COLS||ny<0||ny>=ROWS) continue;
        if(seen[ny][nx]) continue;
        if(board[ny][nx] === animal){
          seen[ny][nx] = true;
          q.push([nx,ny]);
        }
      }
    }
    return cells;
  }

  function applyGravity(){
    for(let x=0;x<COLS;x++){
      let write = ROWS-1;
      for(let y=ROWS-1;y>=0;y--){
        const t = board[y][x];
        if(t !== TILE.EMPTY){
          if(write !== y){
            board[write][x] = t;
            board[y][x] = TILE.EMPTY;
            // NOTE: overlays stay where they are (background), not falling
          }
          write--;
        }
      }
    }
  }

  function computeBestGroup(){
    const seen = Array.from({length: ROWS}, () => Array(COLS).fill(false));
    let best = null;

    for(let y=0;y<ROWS;y++){
      for(let x=0;x<COLS;x++){
        if(seen[y][x]) continue;
        const t = board[y][x];
        if(!ANIMALS.includes(t)){
          seen[y][x] = true;
          continue;
        }
        const cells = floodSameAnimal(x,y,t,seen);
        if(!best || cells.length > best.count){
          best = { animal: t, count: cells.length };
        }
      }
    }
    return best;
  }

  // ======= LOCKING =======
  function lockPiece(){
    if(current.kind === "WOLVES"){
      wolvesExplode(current);
      locks++;
      updateLevel();
      resolveBoard();
      spawnNext();
      draw();
      return;
    }

    // place tiles
    for(let r=0;r<current.matrix.length;r++){
      for(let c=0;c<current.matrix[r].length;c++){
        const v = current.matrix[r][c];
        if(!v) continue;
        const x = current.x + c;
        const y = current.y + r;
        if(y < 0){ gameOverNow(); return; }
        board[y][x] = v;
      }
    }

    // black sheep converts to touched animal on lock
    if(current.kind === "BLACKSHEEP"){
      const chosen = chooseConversionAnimalForBlackSheep(current);
      const cells = footprintCells(current);
      for(const [x,y] of cells){
        board[y][x] = chosen;
      }
    }

    locks++;
    updateLevel();
    resolveBoard();
    spawnNext();
    haptic(10);
  }

  // ======= MOVEMENT =======
  function move(dx){
    if(paused) return;
    if(!collides(current, dx, 0)){
      current.x += dx;
      draw();
    } else {
      haptic(6);
    }
  }

  function dropOne(){
    if(paused) return;
    if(!collides(current, 0, 1)){
      current.y += 1;
      draw();
    } else {
      lockPiece();
      draw();
    }
  }

  function rotate(dirCW=true){
    if(paused) return;
    if(!current.rotates) return;
    const test = dirCW ? rotateCW(current.matrix) : rotateCCW(current.matrix);
    const kicks = [0, -1, 1, -2, 2];
    for(const k of kicks){
      if(!collides(current, k, 0, test)){
        current.matrix = test;
        current.x += k;
        draw();
        haptic(6);
        return;
      }
    }
    haptic(6);
  }

  function getGhostY(piece){
    let y = piece.y;
    while(!collides(piece, 0, (y - piece.y) + 1)) y++;
    return y;
  }

  // ======= PARTICLES =======
  function spawnPopParticles(popped){
    // popped: array of [x,y,tile] or [x,y,animal]
    const dpr = Math.max(1, Math.floor(window.devicePixelRatio || 1));
    const px = pad*dpr;
    for(const item of popped){
      const x=item[0], y=item[1];
      const t=item[2] || TILE.SHEEP;
      const cx = px + x*cell + cell/2;
      const cy = px + y*cell + cell/2;
      const n = 6 + Math.floor(Math.random()*5);
      for(let i=0;i<n;i++){
        particles.push({
          x: cx,
          y: cy,
          vx: (Math.random()*2-1) * (0.9 + Math.random()*1.4),
          vy: (Math.random()*2-1) * (0.9 + Math.random()*1.4) - 1.2,
          life: 26 + Math.floor(Math.random()*14),
          color: TILE_COLOR[t] || "#ddd"
        });
      }
    }
  }

  function stepParticles(){
    if(particles.length === 0) return;
    for(const p of particles){
      p.x += p.vx;
      p.y += p.vy;
      p.vy += 0.10; // gravity
      p.life -= 1;
    }
    particles = particles.filter(p => p.life > 0);
  }

  // ======= DRAWING =======
  function resize(){
    const rect = canvas.getBoundingClientRect();
    const dpr = Math.max(1, Math.floor(window.devicePixelRatio || 1));
    const targetW = Math.floor(rect.width * dpr);

    cell = Math.floor((targetW - pad*2*dpr) / COLS);
    W = cell * COLS + pad*2*dpr;
    H = cell * ROWS + pad*2*dpr;
    canvas.width = W;
    canvas.height = H;
    draw();
  }

  function draw(){
    ctx.clearRect(0,0,W,H);

    // Dark frame
    roundRectFill(0,0,W,H,18, "#050507");

    const dpr = Math.max(1, Math.floor(window.devicePixelRatio || 1));
    const px = pad*dpr;

    // subtle inner vignette
    ctx.save();
    ctx.globalAlpha = 0.22;
    ctx.fillStyle = "#000";
    ctx.fillRect(0,0,W,H);
    ctx.restore();

    // board cells background grid (very subtle)
    for(let y=0;y<ROWS;y++){
      for(let x=0;x<COLS;x++){
        const gx = px + x*cell;
        const gy = px + y*cell;
        ctx.globalAlpha = 0.08;
        ctx.fillStyle = "#ffffff";
        ctx.fillRect(gx+2, gy+2, cell-4, cell-4);
        ctx.globalAlpha = 1;
      }
    }

    // overlays (egg/turd) drawn behind tiles
    drawOverlay(px);

    // placed tiles
    for(let y=0;y<ROWS;y++){
      for(let x=0;x<COLS;x++){
        const t = board[y][x];
        if(t !== TILE.EMPTY) drawTile(x,y,t,px,true);
      }
    }

    // ghost shadow: outline only
    if(current && !paused){
      const gy = getGhostY(current);
      drawShadow(current, 0, gy - current.y, px);
    }

    // current piece
    if(current) drawPiece(current,0,0,px);

    // particles on top
    stepParticles();
    drawParticles();

    // banner
    if(banner.text){
      const now = performance.now();
      const age = now - banner.t;
      if(age < banner.ttl){
        const a = Math.max(0, 1 - age / banner.ttl);
        ctx.save();
        ctx.globalAlpha = 0.70 * a;
        ctx.fillStyle = "#000";
        ctx.fillRect(0,0,W, Math.floor(cell*1.2));
        ctx.globalAlpha = 1 * a;
        ctx.fillStyle = "#fff";
        ctx.font = `${Math.floor(cell*0.55)}px system-ui`;
        ctx.textAlign = "center";
        ctx.textBaseline = "middle";
        ctx.fillText(banner.text, W/2, Math.floor(cell*0.6));
        ctx.restore();
      } else {
        banner.text = "";
      }
    }

    // pause overlay
    if(paused && !gameOver){
      ctx.save();
      ctx.globalAlpha = 0.65;
      ctx.fillStyle = "#000";
      ctx.fillRect(0,0,W,H);
      ctx.globalAlpha = 1;
      ctx.fillStyle = "#fff";
      ctx.font = `${Math.floor(cell*0.9)}px system-ui`;
      ctx.textAlign = "center";
      ctx.fillText("Paused", W/2, H/2);
      ctx.restore();
    }
  }

  function drawOverlay(px){
    // ‚Äúin the mud‚Äù look: faint, slightly rotated; doesn‚Äôt block tiles
    for(let y=0;y<ROWS;y++){
      for(let x=0;x<COLS;x++){
        const p = powerOverlay[y][x];
        if(p === POWER.NONE) continue;

        const gx = px + x*cell;
        const gy = px + y*cell;

        ctx.save();
        ctx.translate(gx + cell/2, gy + cell/2);
        ctx.rotate((x+y)%2 ? -0.12 : 0.10);
        ctx.globalAlpha = 0.45;

        ctx.font = `${Math.floor(cell*0.62)}px system-ui, "Apple Color Emoji", "Segoe UI Emoji"`;
        ctx.textAlign = "center";
        ctx.textBaseline = "middle";
        ctx.fillStyle = "#fff";
        ctx.fillText(p === POWER.EGG ? "ü•ö" : "üí©", 0, 1);

        ctx.restore();
      }
    }
  }

  function drawTile(x,y,t,px,withEmoji){
    const gx = px + x*cell;
    const gy = px + y*cell;

    // fill
    ctx.globalAlpha = 0.96;
    roundRectFill(gx+1, gy+1, cell-2, cell-2, 10, TILE_COLOR[t] || "#ddd");
    ctx.globalAlpha = 1;

    // border
    ctx.save();
    ctx.globalAlpha = 0.28;
    ctx.strokeStyle = "#ffffff";
    ctx.lineWidth = Math.max(1, Math.floor(cell*0.06));
    roundRectStroke(gx+2, gy+2, cell-4, cell-4, 9);
    ctx.restore();

    // highlight strip
    ctx.save();
    ctx.globalAlpha = 0.16;
    ctx.fillStyle = "#ffffff";
    roundRectFill(gx+3, gy+3, cell-6, Math.floor((cell-6)*0.38), 8, "#ffffff");
    ctx.restore();

    if(withEmoji){
      ctx.font = `${Math.floor(cell*0.68)}px system-ui, "Apple Color Emoji", "Segoe UI Emoji"`;
      ctx.textAlign = "center";
      ctx.textBaseline = "middle";
      ctx.fillStyle = "#000";
      ctx.globalAlpha = 0.20;
      ctx.fillText(TILE_LABEL[t] || "?", gx + cell/2 + 1, gy + cell/2 + 2);
      ctx.globalAlpha = 1;
      ctx.fillStyle = "#fff";
      ctx.fillText(TILE_LABEL[t] || "?", gx + cell/2, gy + cell/2 + 1);
    }
  }

  function drawPiece(piece, dx, dy, px){
    const m = piece.matrix;
    for(let r=0;r<m.length;r++){
      for(let c=0;c<m[r].length;c++){
        const v = m[r][c];
        if(!v) continue;
        const x = piece.x + c + dx;
        const y = piece.y + r + dy;
        if(y < 0) continue;
        drawTile(x,y,v,px,true);
      }
    }
  }

  function drawShadow(piece, dx, dy, px){
    // shadow as outline + faint black fill (no emoji)
    const m = piece.matrix;
    ctx.save();
    for(let r=0;r<m.length;r++){
      for(let c=0;c<m[r].length;c++){
        const v = m[r][c];
        if(!v) continue;
        const x = piece.x + c + dx;
        const y = piece.y + r + dy;
        if(y < 0) continue;

        const gx = px + x*cell;
        const gy = px + y*cell;

        ctx.globalAlpha = 0.12;
        roundRectFill(gx+3, gy+3, cell-6, cell-6, 10, "#000");
        ctx.globalAlpha = 0.26;
        ctx.strokeStyle = "rgba(255,255,255,0.65)";
        ctx.lineWidth = Math.max(1, Math.floor(cell*0.055));
        roundRectStroke(gx+3, gy+3, cell-6, cell-6, 10);
      }
    }
    ctx.restore();
  }

  function drawParticles(){
    if(particles.length === 0) return;
    ctx.save();
    for(const p of particles){
      ctx.globalAlpha = clamp(p.life/40, 0, 0.9);
      ctx.fillStyle = p.color;
      ctx.beginPath();
      ctx.arc(p.x, p.y, Math.max(1.5, cell*0.08), 0, Math.PI*2);
      ctx.fill();
    }
    ctx.restore();
  }

  function roundRectFill(x,y,w,h,r,color){
    const rr = Math.min(r, w/2, h/2);
    ctx.beginPath();
    ctx.moveTo(x+rr, y);
    ctx.arcTo(x+w, y, x+w, y+h, rr);
    ctx.arcTo(x+w, y+h, x, y+h, rr);
    ctx.arcTo(x, y+h, x, y, rr);
    ctx.arcTo(x, y, x+w, y, rr);
    ctx.closePath();
    ctx.fillStyle = color;
    ctx.fill();
  }
  function roundRectStroke(x,y,w,h,r){
    const rr = Math.min(r, w/2, h/2);
    ctx.beginPath();
    ctx.moveTo(x+rr, y);
    ctx.arcTo(x+w, y, x+w, y+h, rr);
    ctx.arcTo(x+w, y+h, x, y+h, rr);
    ctx.arcTo(x, y+h, x, y, rr);
    ctx.arcTo(x, y, x+w, y, rr);
    ctx.closePath();
    ctx.stroke();
  }

  // ======= INPUT: TOUCH (NO HOLD-TO-REPEAT; only movement while finger moves) =======
  let touch = null;

  canvas.addEventListener("pointerdown", (e) => {
    e.preventDefault();
    ensureAudio();
    if(audioCtx && audioCtx.state === "suspended") audioCtx.resume();

    touch = {
      x0: e.clientX,
      y0: e.clientY,
      x: e.clientX,
      y: e.clientY,
      movedX: 0,
      movedY: 0,
      t0: performance.now(),
      didRotate: false
    };
  });

  canvas.addEventListener("pointermove", (e) => {
    if(!IS_TOUCH || !touch) return;

    const nx = e.clientX;
    const ny = e.clientY;

    const dx = nx - touch.x;
    const dy = ny - touch.y;

    touch.x = nx;
    touch.y = ny;

    // accumulate for step-based movement
    touch.movedX += dx;
    touch.movedY += dy;

    // horizontal stepping
    while(touch.movedX <= -SWIPE_STEP_X){
      move(-1);
      touch.movedX += SWIPE_STEP_X;
    }
    while(touch.movedX >= SWIPE_STEP_X){
      move(1);
      touch.movedX -= SWIPE_STEP_X;
    }

    // downward stepping (soft drop)
    while(touch.movedY >= SWIPE_STEP_Y){
      dropOne();
      touch.movedY -= SWIPE_STEP_Y;
    }

    // upward rotate: only once per gesture
    const totalUp = touch.y0 - ny;
    if(!touch.didRotate && totalUp >= SWIPE_UP_MIN){
      const totalDx = nx - touch.x0;
      // up-left => CCW, otherwise CW (including straight up)
      rotate(totalDx < 0 ? false : true);
      touch.didRotate = true;
      // reset anchors so additional up motion doesn't keep firing
      touch.x0 = nx;
      touch.y0 = ny;
    }
  });

  canvas.addEventListener("pointerup", (e) => {
    e.preventDefault();
    if(!touch) return;

    // Tap = rotate CW
    const dt = performance.now() - touch.t0;
    const dist = Math.hypot((e.clientX - touch.x0),(e.clientY - touch.y0));
    if(dt < 220 && dist < 10){
      rotate(true);
    }

    touch = null;
  });
  canvas.addEventListener("pointercancel", () => { touch = null; });

  // Desktop fallback (keys) + clicking gear still works
  if(!IS_TOUCH){
    window.addEventListener("keydown", (e) => {
      const k = e.key.toLowerCase();
      if(k === "p"){ paused = !paused; draw(); return; }
      if(paused) return;

      if(e.key === "ArrowLeft") move(-1);
      else if(e.key === "ArrowRight") move(1);
      else if(e.key === "ArrowDown") dropOne();
      else if(k === "z") rotate(false);
      else if(k === "x" || e.key === "ArrowUp") rotate(true);
      else if(k === "r") restart();
    });
  }

  // ======= SETTINGS UI =======
  function openModal(){
    modalBackdrop.style.display = "flex";
  }
  function closeModalFn(){
    modalBackdrop.style.display = "none";
  }
  gear.addEventListener("pointerdown", (e) => { e.preventDefault(); openModal(); });
  closeModal.addEventListener("pointerdown", (e) => { e.preventDefault(); closeModalFn(); });
  modalBackdrop.addEventListener("pointerdown", (e) => {
    // click outside modal
    if(e.target === modalBackdrop) closeModalFn();
  });

  function setSound(on){
    soundOn = on;
    soundSwitch.classList.toggle("on", on);
    soundSwitch.setAttribute("aria-checked", on ? "true" : "false");
  }
  soundSwitch.addEventListener("pointerdown", (e) => {
    e.preventDefault();
    setSound(!soundOn);
    // tiny confirmation click
    ensureAudio();
    if(audioCtx && audioCtx.state === "suspended") audioCtx.resume();
    playTone({type:"sine", f1: soundOn ? 520 : 180, f2: soundOn ? 380 : 120, dur:0.06, gain:0.06});
  });

  // ======= GAME LOOP =======
  function tick(){
    requestAnimationFrame(tick);
    if(paused || gameOver) return;

    if(!current){
      spawnNext();
      updateHUD();
      draw();
      return;
    }

    fallTimer += 16;
    ambienceTimer += 16;

    if(ambienceTimer > 500){
      ambienceTimer = 0;
      playTick();
    }

    if(fallTimer >= fallInterval){
      fallTimer = 0;
      if(!collides(current, 0, 1)){
        current.y += 1;
      } else {
        lockPiece();
      }
      draw();
    } else {
      // lightweight redraw for particles/banner
      if(particles.length) draw();
    }
  }

  // ======= INIT =======
  function init(){
    window.addEventListener("resize", resize, {passive:true});
    const ro = new ResizeObserver(() => resize());
    ro.observe(canvas);

    sprinklePowerOverlay();
    next = newPiece();
    spawnNext();
    updateHUD();
    resize();
    requestAnimationFrame(tick);
  }

  init();
})();
</script>
</body>
</html>
